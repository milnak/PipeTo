/*

PIPETO: Copyright (c) 1995 Charles Beerman.  All Rights Reserved.

Recreated by Jeff Miller 2024. (I couldn't find the original binary location or sources!)

Build with "cl.exe /W4 /WX /Z7 .\PipeTo.c"
*/

#include <windows.h>
#include <stdio.h>
#include <string.h>

#pragma comment(lib, "User32") /*WaitForInputIdle*/

const char *usage01 = "PIPETO: Copyright (c) 1995 Charles Beerman.  All Rights Reserved.\n";
const char *usage02 = "PIPETO [-tee] command-string\n";
const char *usage03 = "This command is usually used in a pipe, to pipe the standard input to the\n";
const char *usage04 = "specified Windows executable.  For example: \"DIR | PIPETO NOTEPAD $$\"\n\n";
const char *usage05 = "In this case, the output of the DIR command is used as input to the Windows\n";
const char *usage06 = "notepad.  The \"$$\" in the command is used as a placeholder for the\n";
const char *usage07 = "temporary file generated by PIPETO to hold the results of the standard\n";
const char *usage08 = "input.  It is needed only if the command needs its filename argument in the\n";
const char *usage09 = "middle of the command string; if the filename argument is at the end of the\n";
const char *usage10 = "command, the \"$$\" can be omitted.  Therefore, the above named example could\n";
const char *usage11 = "could also be written as \"DIR | PIPETO NOTEPAD\"\n\n";
const char *usage12 = "The optional argument \"-tee\" indicates that the standard input is to be\n";
const char *usage13 = "written to the standard output as well as to the specified command.  So the\n";
const char *usage14 = "command\n\n";
const char *usage15 = "  DIR | PIPETO -tee NOTEPAD | GREP FOO\n\n";
const char *usage16 = "will output the results of \"DIR\" to the Notepad and will also pipe them to\n";
const char *usage17 = "the \"GREP\" command.\n";

const char *errorWritingToStandardOutput = "Error writing to standard output\n";
const char *errorWritingToTemporaryFile = "Error writing to temporary file\n";
const char *errorRetrievingTemporaryFilePath = "Error retrieving temporary file path\n";
const char *errorCreatingTemporaryFilename = "Error creating a temporary filename\n";
const char *errorCreatingTemporaryFile = "Error creating the temporary file\n";
const char *errorCreatingChildProcess = "Error creating child process\n";

const char *teeArgument = "-tee";
BOOL teeArgumentSpecified = FALSE;

const char *placeholderArgument = "$$";

const char *tempFileNamePrefix = "PIP";

HANDLE stdErrorHandle = INVALID_HANDLE_VALUE;
HANDLE stdInputHandle = INVALID_HANDLE_VALUE;
HANDLE stdOutputHandle = INVALID_HANDLE_VALUE;
HANDLE tempFileHandle = INVALID_HANDLE_VALUE;
char tempFilenameBuffer[MAX_PATH + 1] = {0};

BOOL WINAPI ConsoleCtrlHandlerProc(DWORD dwCtrlType)
{
    UNREFERENCED_PARAMETER(dwCtrlType);

    if (tempFileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(tempFileHandle);
    }

    DeleteFile(tempFilenameBuffer);
    tempFileHandle = INVALID_HANDLE_VALUE;

    return TRUE;
}

void WriteToStdOut(const char *str)
{
    WriteFile(stdOutputHandle, str, (DWORD)strlen(str), NULL /*lpNumberOfBytesWritten*/, NULL /*lpOverlapped*/);
}

void WriteToStdErr(const char *str)
{
    WriteFile(stdErrorHandle, str, (DWORD)strlen(str), NULL /*lpNumberOfBytesWritten*/, NULL /*lpOverlapped*/);
}

void ShowUsage()
{
    WriteToStdOut(usage01);
    WriteToStdOut(usage02);
    WriteToStdOut(usage03);
    WriteToStdOut(usage04);
    WriteToStdOut(usage05);
    WriteToStdOut(usage06);
    WriteToStdOut(usage07);
    WriteToStdOut(usage08);
    WriteToStdOut(usage09);
    WriteToStdOut(usage10);
    WriteToStdOut(usage11);
    WriteToStdOut(usage12);
    WriteToStdOut(usage13);
    WriteToStdOut(usage14);
    WriteToStdOut(usage15);
    WriteToStdOut(usage16);
    WriteToStdOut(usage17);
}

void ProcessStdin()
{
    while (TRUE)
    {
        BYTE stdInputBuffer[2048];
        DWORD numberOfBytesRead;
        DWORD numberOfBytesWritten;
        BOOL result;

        if (ReadFile(stdInputHandle, stdInputBuffer, ARRAYSIZE(stdInputBuffer), &numberOfBytesRead,
                     NULL /*lpOverlapped*/) == 0)
        {
            break;
        }

        if (numberOfBytesRead == 0)
        {
            break;
        }

        result = WriteFile(tempFileHandle, stdInputBuffer, numberOfBytesRead, &numberOfBytesWritten,
                           NULL /*lpOverlapped*/);
        if (!result || (numberOfBytesWritten != numberOfBytesRead))
        {
            break;
        }

        if (teeArgumentSpecified)
        {
            result = WriteFile(stdOutputHandle, stdInputBuffer, numberOfBytesRead, &numberOfBytesWritten,
                               NULL /*lpOverlapped*/);
            if (!result || (numberOfBytesWritten != numberOfBytesRead))
            {
                WriteToStdErr(errorWritingToStandardOutput);
                break;
            }
        }
    }

    if (teeArgumentSpecified)
    {
        CloseHandle(stdOutputHandle);
        stdOutputHandle = INVALID_HANDLE_VALUE;
    }
}

int main(int argc, char **argv)
{
    char tempPath[MAX_PATH + 1];
    char commandLineBuffer[1024];
    STARTUPINFOA startupInfo;
    PROCESS_INFORMATION processInformation;
    DWORD exitCode;
    int totalArgc = argc;
    BOOL appendedFilenameBuffer = FALSE;

    SetConsoleCtrlHandler(ConsoleCtrlHandlerProc, TRUE);

    stdErrorHandle = GetStdHandle(STD_ERROR_HANDLE);
    stdInputHandle = GetStdHandle(STD_INPUT_HANDLE);
    stdOutputHandle = GetStdHandle(STD_OUTPUT_HANDLE);

    if (argc < 2)
    {
        ShowUsage();
        return 1;
    }

    argc = 1;

    if (strcmp(argv[1], teeArgument) == 0)
    {
        teeArgumentSpecified = TRUE;
        argc = 2;

        if (totalArgc < 3)
        {
            ShowUsage();
            return 2;
        }
    }

    if (GetTempPathA(ARRAYSIZE(tempPath), tempPath) == 0)
    {
        WriteToStdErr(errorRetrievingTemporaryFilePath);
        return 3;
    }

    if (GetTempFileNameA(tempPath, tempFileNamePrefix, 0 /*uUnique*/, tempFilenameBuffer) == 0)
    {
        WriteToStdErr(errorCreatingTemporaryFilename);
        return 4;
    }

    tempFileHandle = CreateFileA(tempFilenameBuffer, GENERIC_WRITE, 0 /*dwShareMode*/, NULL /*lpSecurityAttributes*/,
                                 CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY, NULL /*hTemplateFile*/);
    if (tempFileHandle == INVALID_HANDLE_VALUE)
    {
        WriteToStdErr(errorCreatingTemporaryFile);
        return 5;
    }

    ProcessStdin();

    CloseHandle(tempFileHandle);
    tempFileHandle = INVALID_HANDLE_VALUE;

    /* Build command line */
    commandLineBuffer[0] = '\0';

    if (argc < totalArgc)
    {
        totalArgc = totalArgc - argc;
        argv = &argv[argc];

        do
        {
            if (strcmp(*argv, placeholderArgument) == 0)
            {
                strcat_s(commandLineBuffer, ARRAYSIZE(commandLineBuffer), tempFilenameBuffer);
                appendedFilenameBuffer = TRUE;
            }
            else
            {
                strcat_s(commandLineBuffer, ARRAYSIZE(commandLineBuffer), *argv);
            }

            strcat_s(commandLineBuffer, ARRAYSIZE(commandLineBuffer), " ");

            argv++;
            totalArgc--;
        } while (totalArgc != 0);

        if (!appendedFilenameBuffer)
        {
            strcat_s(commandLineBuffer, ARRAYSIZE(commandLineBuffer), tempFilenameBuffer);
        }
    }

    startupInfo.cb = sizeof(startupInfo);
    startupInfo.lpReserved = 0;
    startupInfo.lpDesktop = 0;
    startupInfo.lpTitle = 0;
    startupInfo.dwFlags = STARTF_USESHOWWINDOW;
    startupInfo.wShowWindow = SW_SHOWNORMAL;
    startupInfo.cbReserved2 = 0;
    startupInfo.lpReserved2 = 0;

    if (CreateProcessA(NULL /*lpApplicationName*/, commandLineBuffer, NULL /*lpProcessAttributes*/,
                       NULL /*lpThreadAttributes*/, TRUE /*bInheritHandles*/, DETACHED_PROCESS /*dwCreationFlags*/,
                       NULL /*lpEnvironment*/, NULL /*lpCurrentDirectory*/, &startupInfo, &processInformation) == 0)
    {
        WriteToStdErr(errorCreatingChildProcess);
        DeleteFileA(tempFilenameBuffer);
        return 6;
    }
    else
    {
        /* Wait up to 30 seconds for process to finish processing its initial input
           and is waiting for user input with no input pending. */
        exitCode = WaitForInputIdle(processInformation.hProcess, 30 * 1000);
        if (exitCode == WAIT_TIMEOUT)
        {
            exitCode = ERROR_NO_MORE_ITEMS;
        }

        do
        {
            if (GetExitCodeProcess(processInformation.hProcess, &exitCode) == 0)
            {
                break;
            }

            Sleep(1 * 1000);
        } while (exitCode == ERROR_NO_MORE_ITEMS);

        DeleteFileA(tempFilenameBuffer);
    }

    return 0;
}
